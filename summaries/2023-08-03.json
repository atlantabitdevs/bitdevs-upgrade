{
  "summary": [
    {
      "summary": "The text is a message to a mailing list discussing the progress of a community process to specify covenants in Bitcoin. The author states that they introduced the idea of the process last year but will no longer actively pursue it. The goals of the process were to evaluate covenant proposals, explore common grounds between proposals, and expand the consensus changes development process beyond Bitcoin Core. Other initiatives related to covenant changes have been undertaken by different individuals and groups. The author acknowledges that their time and focus will be primarily on Lightning Network development, as they believe it is more critical for Bitcoin's survival. They encourage others to continue working on covenant changes and propose the need for technical historians and archivists to assess and preserve proposals. The author also invites individuals interested in maintaining the Bitcoin Contracting Primitives WG or collaborating on industry-wide workshops to reach out.",
      "summaryeli15": "The author of the text is providing an update on their experiment with a new community process to specify covenants in the Bitcoin development community. They discuss their goals for the process, including building a consistent framework to evaluate covenant proposals and opening up the consensus changes development process. They mention other initiatives that have been undertaken during the same period, such as a fork of Bitcoin Core and the archiving of all covenant proposals. The author concludes that while they initially committed to dedicating time to this process, they realize that their main focus should be on Lightning Network development. They encourage others to continue working on covenant changes proposals and emphasize the importance of thorough testing and assessment before deploying any consensus changes. They also invite individuals to step forward if they are interested in maintaining and nurturing the Bitcoin Contracting Primitives Working Group or collaborating on industry workshops.",
      "title": "On the experiment of the Bitcoin Contracting Primitives WG and marking this community process \"up for grabs\"",
      "link": "https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-July/021786.html"
    },
    {
      "summary": "The text describes the implementation of a version of the Schnorr Musig2 protocol for statechains. In this implementation, the server (referred to as party 1) will be fully 'blinded', meaning it will hold a private key required for generating an aggregate signature but will not learn various information such as the aggregate public key, aggregate signature, and the message being signed. The security of this model relies on the statechain server being trusted to report the number of partial signatures generated for a specific key. The implementation follows the steps of the Musig2 protocol, involving the generation of private and public keys, aggregation of public keys, generation of nonces, computation of challenges, and the final signature. To prevent party 1 from learning the full public key or final signature, modifications are made where key aggregation and nonce aggregation are performed by party 2. Party 2 also computes the challenge and sends it to party 1 to calculate their part of the final signature. The text concludes by requesting comments or feedback on potential issues with this implementation.",
      "summaryeli15": "In this text, the author is discussing the implementation of a cryptographic protocol called 2-of-2 Schnorr Musig2 for statechains. Statechains involve the transfer of ownership of digital assets without the need for the blockchain. The author describes a modification to this protocol where one of the parties involved (Party 1) remains 'blinded', meaning they do not have access to certain sensitive information. This modification ensures that Party 1 does not learn the aggregate public key, the aggregate signature, or the message being signed. The security of this blinded statechains model relies on trust in the statechain server to report the number of partial signatures generated for a specific key. The full set of signatures is verified client side. The author explains the step-by-step operation of the Musig2 protocol and then suggests ways to blind Party 1 from certain information to ensure their privacy. The text concludes by asking for feedback and potential issues with the proposed modifications.",
      "title": "Blinded 2-party Musig2",
      "link": "https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2023-July/021792.html"
    },
    {
      "summary": "The text explains a way to compute blinding factors in a payment network such that certain conditions are met. The ultimate receiver has a secret value 'r' and gives the ultimate sender the point 'R', which is equal to 'r' multiplied by 'G'. In the simplest case, where there are no intermediate nodes, the ultimate sender chooses a random scalar 'e' as the error blinding factor and constructs an onion that is decryptable by the ultimate receiver. The ultimate sender then offers a payment with the point 'e * G + R', which the ultimate receiver can claim by revealing 'e + r'.\n\nWhen there is an intermediate node, the ultimate sender needs to generate two scalars, 'c' and 'd', such that 'c + d = e'. The ultimate sender then encrypts the onion with 'e' encrypted to the ultimate receiver and 'd' encrypted to the intermediate node. Each intermediate node adds its per-hop blinding factor times 'G' to the input point and sends the result as the output point to the next hop. The process ensures that the ultimate receiver cannot differentiate whether it received the payment through an intermediate node or directly.\n\nIf an intermediate node is a trampoline node and the ultimate sender does not provide a detailed route, the process is similar. The ultimate sender creates a trampoline-level onion and encrypts 'd' and the next trampoline hop to the intermediate node. The intermediate node then finds a route to the next hop and creates a new onion with 'b' encrypted to the next hop and the previous data copied. This process continues until the payment reaches the ultimate receiver. The ultimate receiver still receives the same 'e * G + R' and cannot differentiate between the routes.\n\nIn all cases, the intermediate nodes have enough data to claim their incoming payments, and only the ultimate sender knows the value 'c', which allows it to recover 'r'.",
      "summaryeli15": "This text discusses a method for computing blinding factors in a secure communication system. In this system, each node in the network has a specific role. The ultimate receiver has a secret value `r` and shares a point `R` with the ultimate sender. When the ultimate sender wants to send a message directly to the ultimate receiver, it uses a randomly generated blinding factor `e` and constructs an encrypted message. The ultimate receiver can decrypt this message by revealing `e + r`. \n\nHowever, if there is an intermediate node called Carol between the ultimate sender and receiver, the process becomes more complex. In this case, the ultimate sender needs to generate two blinding factors, `c` and `d`, such that `c + d = e`. The message is then encrypted and sent to Carol, who adds her own blinding factor and forwards it to the next hop. Despite the presence of Carol, the ultimate receiver still sees the same message, `e * G + R`. \n\nThe text also explains how this method can be extended to involving Trampoline nodes, where the ultimate receiver is the final Trampoline hop. In this scenario, the ultimate sender encrypts the message including the next hop's node ID before sending it to Carol. Carol, being a Trampoline node, looks for a route to the ultimate receiver and adds her own blinding factor. The message is then forwarded to Alice, who decrypts it and adds her own blinding factor as well. Finally, the message reaches the ultimate receiver, who sees the same message as before. \n\nOverall, this method allows for secure communication between multiple nodes, with blinding factors ensuring the privacy and authenticity of the messages.",
      "title": "Computing Blinding Factors in a PTLC and Trampoline World",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003999.html"
    },
    {
      "summary": "In a recent update, the LNbits team discovered a serious exploit in their system that allowed an attacker to create balances fraudulently. They have released a patch and urge users to update immediately. The attack was possible due to a flaw in how invoices were handled internally. The attacker was able to insert a payment hash from one payment into a different payment, tricking the system into thinking they were the same. By creating a new account and paying with the manipulated invoice, the attacker was able to gain unauthorized funds. To mitigate this, backends should use unique \"checking id's\" or additional checks to prevent invoice manipulation. Two lessons from this incident are the sophistication of LN-savvy attackers and the misunderstanding of the \"payment hash\" field, which is actually a preimage hash and does not commit to payment details. Developers are encouraged to refer to it as the \"preimage hash\" moving forward.",
      "summaryeli15": "LNbits, a team that focuses on Lightning Network applications, has found a significant exploit in the handling of invoices that could allow attackers to create fraudulent balances. The exploit involves inserting a payment hash from one payment into a different one, creating a malicious invoice that appears legitimate to the backend system. LNbits has patched this vulnerability in their latest version and urges users to update as soon as possible. They also recommend that developers working on similar applications take note of this exploit and implement additional checks to prevent it. The incident serves as a reminder of the sophistication of attackers in the Lightning Network space and highlights the need for a better understanding of payment hashes.",
      "title": "Potential vulnerability in Lightning backends: BOLT-11 \"payment hash\" does not commit to payment!",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-June/003983.html"
    },
    {
      "summary": "The author is sharing one of their side projects where they collect data on the lightning network. They want to track the network's evolution, evaluate proposed solutions, and support university research that lacks real data access. Their goal is to define and collect information that can be shared to assess ideas and proposals. They provide a more detailed description of their project in [1], and there is an experimental explorer available at [2]. They also mention the availability of a public Graphql API at [3]. The author hopes that their project will be beneficial to others. Vincent is the person behind the project.",
      "summaryeli15": "Vincent has a side project where he collects data on the lightning network. He wants to track the network's development and see the impact of different proposals on the network. He also wants to support university research by providing real data. You can find more detailed information about his project in [1], and he has an experimental explorer available at [2]. Additionally, there is a public Graphql API [3] that you can access. Vincent hopes that his project will be helpful to others.",
      "title": "An Open Source Framework to Collect Lightning Network Metrics",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004011.html"
    },
    {
      "summary": "The text discusses various topics related to the lightning network and its ongoing development. It mentions the annual specification meeting that took place in NYC, where transcript-style notes were taken. The discussion covers different proposals, such as package relay, minimum relay fees, ephemeral anchors, HLTCs, and the concept of top of block mempool. The text also touches on other subjects like Taproot, gossip versions, reputation for channel jamming, simplified commitments, the meta-spec process, and async payments/trampoline. The ideas mentioned are aimed at improving the functionality and efficiency of the lightning network protocol.",
      "summaryeli15": "The text discusses various topics related to the Lightning Network specification. It covers package relay, V3 transactions, ephemeral anchors, cluster mempool, taproot, gossip versions, channel jamming mitigation, reputation system, simplified commitments, and async payments/trampoline. The author suggests using modular extensions instead of a single living document for the specification to make it more readable, manageable, and accountable. The need for versioning, cleanups, and improved rationale sections is also discussed. The text provides insights into the technical aspects and challenges of implementing these features in the Lightning Network.",
      "title": "LN Summit 2023 Notes",
      "link": "https://lists.linuxfoundation.org/pipermail/lightning-dev/2023-July/004014.html"
    }
  ]
}